
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dcmst_construction_algorithms.ant_colony_optimisation &#8212; LEO_Satellite_Network_Topology_Design 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for dcmst_construction_algorithms.ant_colony_optimisation</h1><div class="highlight"><pre>
<span></span><span class="c1"># Libraries</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">random</span>


<div class="viewcode-block" id="Ant"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.Ant">[docs]</a><span class="k">class</span> <span class="nc">Ant</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to initialise a member of the Ant class in the ACO DCMST construction algorithm.</span>
<span class="sd">        :param location:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">location</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tabu_list</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([])</span>

<div class="viewcode-block" id="Ant.reset"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.Ant.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_sat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used by ACO DCMST construction algorithm to &quot;reset&quot; an ant for the next iteration of the algorithm.</span>
<span class="sd">        :param num_sat:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coin_flip</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">coin_flip</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_sat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tabu_list</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="Edge"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.Edge">[docs]</a><span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">,</span> <span class="n">min_cost</span><span class="p">,</span> <span class="n">edge_cost</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to initialise a member of the Edge class in the ACO DCMST construction algorithm.</span>
<span class="sd">        :param max_cost:</span>
<span class="sd">        :param min_cost:</span>
<span class="sd">        :param edge_cost:</span>
<span class="sd">        :param u:</span>
<span class="sd">        :param v:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_cost</span> <span class="o">=</span> <span class="n">edge_cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initPhm</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_cost</span> <span class="o">-</span> <span class="n">edge_cost</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">max_cost</span> <span class="o">-</span> <span class="n">min_cost</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initPhm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nVisited</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="Edge.update_pheromone"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.Edge.update_pheromone">[docs]</a>    <span class="k">def</span> <span class="nf">update_pheromone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">minPhm</span><span class="p">,</span> <span class="n">maxPhm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used by Edge class in ACO DCMST construction algorithm to update pheromones of the edge.</span>
<span class="sd">        :param eta:</span>
<span class="sd">        :param minPhm:</span>
<span class="sd">        :param maxPhm:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">eta</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nVisited</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">initPhm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nVisited</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">&gt;</span> <span class="n">maxPhm</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">=</span> <span class="n">maxPhm</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">initPhm</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">&lt;</span> <span class="n">minPhm</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">=</span> <span class="n">minPhm</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">initPhm</span></div>

<div class="viewcode-block" id="Edge.enhance"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.Edge.enhance">[docs]</a>    <span class="k">def</span> <span class="nf">enhance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used by ACO DCMST construction algorithm to update pheromones of edges found in the best DCMST found (so far) by</span>
<span class="sd">        the algorithm.</span>
<span class="sd">        :param gamma:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">*</span> <span class="n">gamma</span></div>

<div class="viewcode-block" id="Edge.restart"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.Edge.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used by ACO DCMST construction algorithm to escape local optimum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phm</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="initialise_ants_and_edges"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.initialise_ants_and_edges">[docs]</a><span class="k">def</span> <span class="nf">initialise_ants_and_edges</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">,</span> <span class="n">num_sat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialises ants and edges (they are associated with other values, such as pheromones) for ACO DCMST construction</span>
<span class="sd">    algorithm.</span>
<span class="sd">    :param cost_matrix:</span>
<span class="sd">    :param num_sat:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># CREATE ANTS #</span>

    <span class="c1"># Initialise an ant at each vertex (cardinality will always be the number of satellites in the network)</span>
    <span class="n">ants</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ant</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sat</span><span class="p">)]</span>

    <span class="c1"># CREATE EDGES #</span>

    <span class="n">max_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">)</span>
    <span class="n">min_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">[</span><span class="n">cost_matrix</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">graph_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cost_matrix</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">graph_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">graph_edges</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">Edge</span><span class="p">(</span><span class="n">max_cost</span><span class="p">,</span> <span class="n">min_cost</span><span class="p">,</span> <span class="n">cost_matrix</span><span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph_edges</span><span class="p">]</span>

    <span class="c1"># Calculate min and max pheromone each edge can have</span>
    <span class="n">maxPhm</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_cost</span> <span class="o">-</span> <span class="n">min_cost</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">max_cost</span> <span class="o">-</span> <span class="n">min_cost</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="n">minPhm</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_cost</span> <span class="o">-</span> <span class="n">min_cost</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="k">return</span> <span class="n">ants</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">maxPhm</span><span class="p">,</span> <span class="n">minPhm</span></div>


<div class="viewcode-block" id="construct_spanning_tree"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.construct_spanning_tree">[docs]</a><span class="k">def</span> <span class="nf">construct_spanning_tree</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">nCandidates</span><span class="p">,</span> <span class="n">num_sat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modified version of Kruskal&#39;s algorithm used to construct a DCMST - used in the ACO algorithm to create a DCMST</span>
<span class="sd">    based on pheromones laid by ants and edge costs.</span>
<span class="sd">    :param edges:</span>
<span class="sd">    :param constraints:</span>
<span class="sd">    :param nCandidates:</span>
<span class="sd">    :param num_sat:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialise spanning tree and degrees of each vertex</span>
    <span class="n">T_n</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">degrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sat</span><span class="p">)])</span>

    <span class="c1"># Sort edges in decreasing order according to pheromone level</span>
    <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">phm</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Select top nCandidates edges from E</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nCandidates</span><span class="p">:</span>
        <span class="n">candidate_edges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">edges</span><span class="p">[:</span><span class="n">nCandidates</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">candidate_edges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

    <span class="c1"># Sort edges according to increasing edge cost</span>
    <span class="n">candidate_edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">edge_cost</span><span class="p">)</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

    <span class="n">level_of_candidates</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_sat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>

        <span class="n">candidate</span> <span class="o">=</span> <span class="n">candidate_edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Check if degree constraint violated by adding edge to tree</span>
        <span class="k">if</span> <span class="n">degrees</span><span class="p">[</span><span class="n">candidate</span><span class="o">.</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">constraints</span><span class="p">[</span><span class="n">candidate</span><span class="o">.</span><span class="n">u</span><span class="p">]</span> <span class="ow">and</span> <span class="n">degrees</span><span class="p">[</span><span class="n">candidate</span><span class="o">.</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">constraints</span><span class="p">[</span><span class="n">candidate</span><span class="o">.</span><span class="n">v</span><span class="p">]:</span>

            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">candidate</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>

            <span class="c1"># Check if cycle created (i.e. no longer a tree if edge added)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">simple_cycles</span><span class="p">(</span><span class="n">G</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">candidate</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">T_n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                <span class="n">degrees</span><span class="p">[</span><span class="n">candidate</span><span class="o">.</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">degrees</span><span class="p">[</span><span class="n">candidate</span><span class="o">.</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Select next best candidates (if more edges are needed)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">nCandidates</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DCMST cannot be constructed, as not enough edges.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Calculate new slice indices</span>
                <span class="n">lowest</span> <span class="o">=</span> <span class="n">level_of_candidates</span> <span class="o">*</span> <span class="n">nCandidates</span>
                <span class="n">level_of_candidates</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">highest</span> <span class="o">=</span> <span class="n">level_of_candidates</span> <span class="o">*</span> <span class="n">nCandidates</span>
                <span class="k">if</span> <span class="n">highest</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lowest</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DCMST cannot be constructed, as not enough edges.&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">highest</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
                    <span class="n">candidate_edges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">lowest</span><span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">candidate_edges</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">lowest</span><span class="p">:</span><span class="n">highest</span><span class="p">])</span>
                <span class="c1"># Sort C in order of increasing edge cost</span>
                <span class="n">candidate_edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">edge_cost</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">T_n</span></div>







<span class="c1"># OPTIMISE BY CHANGING SPANNING TREE ALGORITHM - USE MODIFIED PRIM&#39;S INSTEAD OF KRUSKAL</span>







<div class="viewcode-block" id="move_ants"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.move_ants">[docs]</a><span class="k">def</span> <span class="nf">move_ants</span><span class="p">(</span><span class="n">ants</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">max_steps</span><span class="p">,</span> <span class="n">update_period</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">minPhm</span><span class="p">,</span> <span class="n">maxPhm</span><span class="p">):</span>

    <span class="c1"># The ants explore for a given number of steps</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_steps</span><span class="p">):</span>
        <span class="c1"># Update pheromones of edges after a given number of steps - helps reduce execution time.</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">%</span> <span class="n">update_period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">update_pheromone</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">minPhm</span><span class="p">,</span> <span class="n">maxPhm</span><span class="p">)</span>

        <span class="c1"># Move each ant</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ants</span><span class="p">:</span>

            <span class="n">nAttempts</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">moved</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Move between five vertices or until ant cannot move (which over occurs first).</span>
            <span class="k">while</span> <span class="n">moved</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">nAttempts</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>

                <span class="n">v_1</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">location</span>

                <span class="c1"># Select random edge from edges incident to v_1 with probability proportional to pheromone on edge</span>
                <span class="n">potential_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">],</span> <span class="n">edge</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span> <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">==</span> <span class="n">v_1</span> <span class="ow">or</span>
                                   <span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">==</span> <span class="n">v_1</span><span class="p">]</span>

                <span class="c1"># Select an edge adjacent to the vertex at which ant is located randomly (but proportional to the</span>
                <span class="c1"># pheromone on that edge)</span>
                <span class="n">random_edge</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">potential_edges</span><span class="p">],</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">phm</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">potential_edges</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Find neighbouring vertex</span>
                <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="n">random_edge</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">==</span> <span class="n">v_1</span><span class="p">:</span>
                    <span class="n">v_2</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">random_edge</span><span class="p">]</span><span class="o">.</span><span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v_2</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">random_edge</span><span class="p">]</span><span class="o">.</span><span class="n">u</span>

                <span class="c1"># If ant has not visited that vertex recently, move ant to that vertex</span>
                <span class="k">if</span> <span class="n">v_2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">tabu_list</span><span class="p">:</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">tabu_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_2</span><span class="p">)</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">v_2</span>
                    <span class="n">edges</span><span class="p">[</span><span class="n">random_edge</span><span class="p">]</span><span class="o">.</span><span class="n">nVisited</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">moved</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nAttempts</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">ants</span><span class="p">,</span> <span class="n">edges</span></div>


<span class="c1"># def two_edge_replacement(T, num_sat):</span>
<span class="c1">#     T_n = T</span>
<span class="c1">#     nTries = 0</span>
<span class="c1">#     while nTries &lt; num_sat / 2:</span>
<span class="c1">#         # Select random edge in T_n</span>
<span class="c1">#         e_1 = random.randint(0, len(T_n))</span>
<span class="c1">#         e_b = e_1</span>
<span class="c1">#         c_b = 0</span>
<span class="c1">#         # for e in T</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def one_edge_replacement():</span>
<span class="c1">#     pass</span>


<div class="viewcode-block" id="solution_fitness"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.solution_fitness">[docs]</a><span class="k">def</span> <span class="nf">solution_fitness</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the sum of all edge costs within a given DCMST - used by the ACO DCMST construction algorithm.</span>
<span class="sd">    :param tree:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">edge</span><span class="o">.</span><span class="n">edge_cost</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">])</span></div>


<div class="viewcode-block" id="ant_colony"><a class="viewcode-back" href="../../dcmst_construction_algorithms.ant_colony_optimisation.html#dcmst_construction_algorithms.ant_colony_optimisation.ant_colony">[docs]</a><span class="k">def</span> <span class="nf">ant_colony</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">num_sat</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">max_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
               <span class="n">max_iterations_without_improvement</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2500</span><span class="p">,</span> <span class="n">max_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
               <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">eta_change</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span> <span class="n">gamma_change</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.05</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Algorithm that constructs a DCMST using an ant-based algorithm. Adapted from T. N. Bui, X. Deng, and C. M. Zrncic,</span>
<span class="sd">     “An Improved Ant-Based Algorithm for the Degree-Constrained Minimum Spanning Tree Problem,” IEEE Trans. On Evol.</span>
<span class="sd">     Computation, vol. 16, no. 2, pp. 266-278, Apr. 2012., doi: 10.1109/TEVC.2011.2125971. Default values for function</span>
<span class="sd">     recommended by this original paper.</span>
<span class="sd">    :param cost_matrix:</span>
<span class="sd">    :param constraints:</span>
<span class="sd">    :param num_sat:</span>
<span class="sd">    :param max_iterations:</span>
<span class="sd">    :param max_iterations_without_improvement:</span>
<span class="sd">    :param max_steps:</span>
<span class="sd">    :param eta:</span>
<span class="sd">    :param gamma:</span>
<span class="sd">    :param eta_change:</span>
<span class="sd">    :param gamma_change:</span>
<span class="sd">    :param R:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialise counters</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">i_best</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_restart</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Initialise candidate set cardinality (value recommended by original paper)</span>
    <span class="n">candidate_set_cardinality</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">num_sat</span>

    <span class="c1"># Initialise update period (value recommended by original paper)</span>
    <span class="n">update_period</span> <span class="o">=</span> <span class="n">max_steps</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="c1"># Initialise |V| ants and edges with corresponding pheromone levels</span>
    <span class="n">ants</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">maxPhm</span><span class="p">,</span> <span class="n">minPhm</span> <span class="o">=</span> <span class="n">initialise_ants_and_edges</span><span class="p">(</span><span class="n">cost_matrix</span><span class="p">,</span> <span class="n">num_sat</span><span class="p">)</span>

    <span class="c1"># Construct spanning tree</span>
    <span class="n">best_spanning_tree</span> <span class="o">=</span> <span class="n">construct_spanning_tree</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">candidate_set_cardinality</span><span class="p">,</span> <span class="n">num_sat</span><span class="p">)</span>

    <span class="c1"># Calculate fitness of spanning tree</span>
    <span class="n">best_fitness</span> <span class="o">=</span> <span class="n">solution_fitness</span><span class="p">(</span><span class="n">best_spanning_tree</span><span class="p">)</span>

    <span class="c1"># Continues iteratively improving DCMST until either the maximum number of iterations exceeded or no improvements</span>
    <span class="c1"># have been made in a set number of iterations</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_iterations</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">i_best</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_iterations_without_improvement</span><span class="p">:</span>

        <span class="c1"># ANT EXPLORATION #</span>

        <span class="n">ants</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">move_ants</span><span class="p">(</span><span class="n">ants</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">max_steps</span><span class="p">,</span> <span class="n">update_period</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">minPhm</span><span class="p">,</span> <span class="n">maxPhm</span><span class="p">)</span>

        <span class="c1"># Construct new spanning tree based on exploration</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">construct_spanning_tree</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">candidate_set_cardinality</span><span class="p">,</span> <span class="n">num_sat</span><span class="p">)</span>

        <span class="c1"># REMOVED AS SIGNIFICANTLY INCREASES RUN TIME - IMPLEMENT!</span>

        <span class="c1"># LOCAL OPTIMISATION #</span>
        <span class="c1"># T = two_edge_replacement(T)</span>
        <span class="c1"># T = one_edge_replacement()</span>

        <span class="c1"># Compare the fitness of current best solution to new one</span>
        <span class="n">current_solution_fitness</span> <span class="o">=</span> <span class="n">solution_fitness</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Update spanning tree if better DCMST has been found</span>
        <span class="k">if</span> <span class="n">current_solution_fitness</span> <span class="o">&lt;</span> <span class="n">best_fitness</span><span class="p">:</span>
            <span class="n">best_spanning_tree</span> <span class="o">=</span> <span class="n">T</span>
            <span class="n">best_fitness</span> <span class="o">=</span> <span class="n">current_solution_fitness</span>
            <span class="n">i_best</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1"># ENHANCE #</span>

        <span class="c1"># Enhance edges (lay pheromones) - update pheromones of all edges in the best solution found so far</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">best_spanning_tree</span><span class="p">:</span>
            <span class="c1"># Find edge in main set of edges and update accordingly</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">==</span> <span class="n">edge</span><span class="o">.</span><span class="n">u</span> <span class="ow">and</span> <span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">==</span> <span class="n">edge</span><span class="o">.</span><span class="n">v</span><span class="p">:</span>
                    <span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">enhance</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="c1"># RESTART #</span>

        <span class="c1"># This prevents algorithm getting stuck in local optimum - restart algorithm (i.e. adjust edge pheromones)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">i_best</span><span class="p">,</span> <span class="n">i_restart</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">:</span>
            <span class="n">i_restart</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">best_spanning_tree</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">==</span> <span class="n">edge</span><span class="o">.</span><span class="n">u</span> <span class="ow">and</span> <span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">==</span> <span class="n">edge</span><span class="o">.</span><span class="n">v</span><span class="p">:</span>
                        <span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">restart</span><span class="p">()</span>
                        <span class="k">break</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># RESET ANTS #</span>

        <span class="c1"># In next iteration, reset ants - approximately half (coin toss) of all ants remain in their current locations</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ants</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">num_sat</span><span class="p">)</span>

        <span class="c1"># Update gamma and eta</span>
        <span class="n">gamma</span> <span class="o">*=</span> <span class="n">gamma_change</span>
        <span class="n">eta</span> <span class="o">*=</span> <span class="n">eta_change</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">e</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">best_spanning_tree</span><span class="p">]</span>

    <span class="n">best_spanning_tree_adjacency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_sat</span><span class="p">,</span> <span class="n">num_sat</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">best_spanning_tree_adjacency</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">best_spanning_tree_adjacency</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">best_spanning_tree_adjacency</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">best_spanning_tree_adjacency</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>

<span class="c1"># References</span>
<span class="c1"># Array of Objects - https://stackoverflow.com/questions/4877624/numpy-array-of-objects</span>
<span class="c1"># Cycle Detection - https://en.wikipedia.org/wiki/Cycle_(graph_theory)</span>
<span class="c1"># Deep Copies - https://stackoverflow.com/questions/37593013/deep-copy-of-a-np-array-of-np-array</span>
<span class="c1"># Searching Numpy Arrays - https://stackoverflow.com/questions/3030480/how-do-i-select-elements-of-an-array-given-</span>
<span class="c1"># condition</span>
<span class="c1"># Sorting Objects - https://stackoverflow.com/questions/403421/how-do-i-sort-a-list-of-objects-based-on-an-attribute-of-</span>
<span class="c1"># the-objects</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">LEO_Satellite_Network_Topology_Design</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">project</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2025, Millicent Riordan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>